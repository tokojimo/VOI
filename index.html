<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Analyse VOI - version statique</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
  <script
    src="https://cdnjs.cloudflare.com/ajax/libs/PapaParse/5.4.1/papaparse.min.js"
    integrity="sha512-dfX5uYVXzyU8+KHqj8bjo7UkOdg18PaOtpa48djpNbZHwExddghZ+ZmzWT06R5v6NSk3ZUfsH6FNEDepLx9hPQ=="
    crossorigin="anonymous"
    referrerpolicy="no-referrer"
  ></script>
  <!--
    Hachage SRI officiel de Leaflet 1.9.4 (source : https://unpkg.com/leaflet@1.9.4/dist/).
    Pour le vérifier ou le régénérer lors d'une mise à jour, télécharger le fichier puis exécuter :
      openssl dgst -sha256 -binary leaflet.js | openssl base64 -A
    La carte fonctionne sans l'attribut "integrity", mais le conserver garantit que le fichier chargé
    n'a pas été altéré sur le CDN.
  -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>
  <style>
    :root {
      --bg: #f5f5f7;
      --panel: #ffffff;
      --accent: #0a84ff;
      --text: #0f172a;
      --muted: #4b5563;
      --border: #e5e7eb;
      --shadow: 0 12px 40px rgba(15, 23, 42, 0.08);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      background: radial-gradient(circle at 20% 20%, rgba(10, 132, 255, 0.07), transparent 35%),
        radial-gradient(circle at 80% 0%, rgba(52, 199, 89, 0.08), transparent 30%),
        var(--bg);
      color: var(--text);
      font-family: 'Inter', system-ui, -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      line-height: 1.5;
    }
    header {
      padding: 24px 32px 12px;
      border-bottom: 1px solid var(--border);
      background: rgba(255, 255, 255, 0.85);
      backdrop-filter: blur(10px);
      position: sticky;
      top: 0;
      z-index: 5;
    }
    h1 { margin: 0 0 8px; font-size: 28px; letter-spacing: -0.02em; }
    h2 { margin-top: 24px; margin-bottom: 12px; letter-spacing: -0.01em; }
    p { margin: 8px 0 0; color: var(--muted); }
    .container { padding: 16px 32px 32px; max-width: 1200px; margin: 0 auto; }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      gap: 16px;
      margin-top: 16px;
    }
    .card {
      background: var(--panel);
      border: 1px solid var(--border);
      border-radius: 14px;
      padding: 16px;
      box-shadow: var(--shadow);
    }
    label { font-weight: 600; display: block; margin-bottom: 6px; }
    input[type="file"] {
      width: 100%;
      background: #f8fafc;
      border: 1px dashed var(--border);
      color: var(--muted);
      padding: 10px;
      border-radius: 10px;
    }
    button {
      background: linear-gradient(135deg, #0a84ff, #0f6add);
      color: #ffffff;
      border: none;
      border-radius: 12px;
      padding: 11px 16px;
      font-weight: 700;
      cursor: pointer;
      box-shadow: 0 10px 30px rgba(10, 132, 255, 0.25);
      transition: transform 0.1s ease, box-shadow 0.2s ease, filter 0.2s ease;
    }
    button:hover { filter: brightness(1.02); box-shadow: 0 14px 34px rgba(10, 132, 255, 0.32); }
    button:active { transform: translateY(1px); }
    .inline { display: inline-flex; align-items: center; gap: 8px; }
    .pill {
      display: inline-block;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(10, 132, 255, 0.12);
      color: var(--text);
      border: 1px solid rgba(10, 132, 255, 0.2);
      font-size: 13px;
      margin-right: 6px;
    }
    .muted { color: var(--muted); }
    .metrics { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 12px; margin-top: 10px; }
    .metric { padding: 12px; background: #f8fafc; border: 1px solid var(--border); border-radius: 12px; }
    .metric strong { display: block; font-size: 22px; letter-spacing: -0.01em; }
    #charts { display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 16px; }
    .plot { min-height: 320px; }
    #map { height: 420px; border-radius: 14px; overflow: hidden; box-shadow: var(--shadow); }
    #routeMap { height: 460px; border-radius: 14px; overflow: hidden; margin-top: 12px; box-shadow: var(--shadow); }
    .footer { margin-top: 32px; color: var(--muted); font-size: 14px; }
    a { color: #22d3ee; }
    .filters-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(220px, 1fr)); gap: 12px; }
    .control { display: flex; flex-direction: column; gap: 6px; }
    select, input[type="number"], input[type="datetime-local"] {
      background: #f8fafc;
      border: 1px solid var(--border);
      color: var(--text);
      padding: 10px 12px;
      border-radius: 12px;
    }
    .pill-button {
      border: 1px solid var(--border);
      background: #f8fafc;
      color: var(--text);
      padding: 9px 12px;
      border-radius: 999px;
      cursor: pointer;
      transition: background 0.2s ease, border-color 0.2s ease, box-shadow 0.2s ease;
    }
    .pill-button:hover { border-color: #0a84ff; box-shadow: 0 6px 20px rgba(15, 23, 42, 0.12); }
    .vehicle-list { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 12px; }
    .vehicle-item { padding: 9px 11px; border-radius: 12px; border: 1px solid var(--border); background: #f8fafc; cursor: pointer; }
    .vehicle-item.active { border-color: #0a84ff; box-shadow: 0 0 0 1px rgba(10, 132, 255, 0.35); }
    .muted-text { color: var(--muted); font-size: 14px; }
    .badge { background: rgba(10, 132, 255, 0.15); color: var(--text); padding: 4px 8px; border-radius: 10px; border: 1px solid rgba(10, 132, 255, 0.4); font-size: 12px; }
  </style>
</head>
<body>
  <header>
    <div class="inline">
      <h1>VOI – Tableau de bord statique</h1>
      <span class="pill">Client-side only</span>
    </div>
    <p>Analyse rapide des flux VOI directement dans le navigateur, sans backend Streamlit. Les exports fournis dans le dépôt sont chargés automatiquement pour illustrer les visualisations.</p>
  </header>
  <div class="container">
    <div class="grid">
      <div class="card">
        <h2>Données de démonstration</h2>
        <p class="muted">Les exports NDJSON/CSV sont préchargés depuis le dépôt GitHub pour simplifier l'exploration.</p>
        <div style="margin-top: 12px; display: flex; gap: 8px;">
          <button id="demoBtn" type="button">Recharger les données</button>
        </div>
      </div>
      <div class="card">
        <h2>Résumé</h2>
        <div class="metrics">
          <div class="metric"><span class="muted">Événements</span><strong id="eventsCount">–</strong></div>
          <div class="metric"><span class="muted">Trottinettes</span><strong id="vehiclesCount">–</strong></div>
          <div class="metric"><span class="muted">Période couverte</span><strong id="dateRange">–</strong></div>
        </div>
      </div>
    </div>

    <div id="charts" style="margin-top: 20px;">
      <div class="card"><h2>Flux quotidiens</h2><div id="dailyChart" class="plot"></div></div>
      <div class="card"><h2>Stations les plus actives</h2><div id="stationChart" class="plot"></div></div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Carte des stations</h2>
      <div id="map"></div>
      <div id="mapStatus" class="muted-text" style="margin-top: 8px;"></div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Explorateur de trajets</h2>
      <p class="muted">Choisissez une station et une plage horaire pour afficher les trajets reconstruits. Cliquez sur une station directement sur la carte ou sélectionnez un véhicule pour ne voir que son parcours.</p>
      <div class="filters-grid" style="margin-top: 12px;">
        <div class="control">
          <label for="stationSelect">Station (arrivée ou départ)</label>
          <select id="stationSelect"></select>
        </div>
        <div class="control">
          <label for="startHour">Heure de début</label>
          <input id="startHour" type="number" min="0" max="23" value="0" />
        </div>
        <div class="control">
          <label for="endHour">Heure de fin</label>
          <input id="endHour" type="number" min="0" max="23" value="23" />
        </div>
        <div class="control">
          <label>&nbsp;</label>
          <button id="resetFilters" type="button" class="pill-button">Réinitialiser les filtres</button>
        </div>
      </div>
      <div id="tripSummary" class="muted-text" style="margin-top: 10px;"></div>
      <div id="routeMap"></div>
      <div style="margin-top: 12px;">
        <strong>Véhicules</strong>
        <div id="vehiclesList" class="vehicle-list"></div>
      </div>
    </div>

    <div class="card" style="margin-top: 20px;">
      <h2>Détails</h2>
      <p class="muted">Exportez vos visualisations via le menu contextuel de Plotly. Les traitements reproduisent les étapes essentielles du code Streamlit : filtrage IN/OUT, tri chronologique et association des métadonnées stations.</p>
    </div>

    <div class="footer">Source : <a href="https://github.com/tokojimo/VOI" target="_blank" rel="noopener">tokojimo/VOI</a>. Cette page fonctionne sur GitHub Pages ou tout serveur statique.</div>
  </div>

  <script>
    const parisOffsetMinutes = new Date().getTimezoneOffset();

    async function readFileText(file) {
      return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsText(file);
      });
    }

    function parseTimestamp(row) {
      if (!row) return null;
      const iso = row.t_iso;
      const ms = row.t_ms;
      const misc = row.t;
      let date = null;
      if (iso) {
        date = new Date(iso);
      } else if (ms) {
        date = new Date(Number(ms));
      } else if (typeof misc === 'string' && misc.startsWith('/Date(')) {
        const value = Number(misc.replace(/\D/g, ''));
        date = new Date(value);
      }
      return isNaN(date?.getTime()) ? null : date;
    }

    function normalizeStationName(row) {
      return row.station_name || row.name || row.station || null;
    }

    function parseNdjson(content) {
      return content
        .split(/\r?\n/)
        .map((line) => line.trim())
        .filter(Boolean)
        .map((line) => {
          try { return JSON.parse(line); } catch { return null; }
        })
        .filter(Boolean);
    }

    function normalizeType(type) {
      const normalized = (type || '').toString().toUpperCase();
      return normalized === 'INIT' ? 'IN' : normalized;
    }

    function filterEvents(rows) {
      return rows
        .map((row) => ({ ...row, type: normalizeType(row.type), ts: parseTimestamp(row) }))
        .filter((row) => row.ts && (row.type === 'IN' || row.type === 'OUT'))
        .sort((a, b) => a.ts - b.ts);
    }

    function attachStations(events, stations) {
      if (!stations.length) return events.map((e) => ({ ...e, station_name: normalizeStationName(e) }));
      const byId = new Map(stations.map((s) => [String(s.station_id), s]));
      return events.map((e) => {
        const meta = byId.get(String(e.station_id)) || {};
        return {
          ...e,
          station_name: meta.station_name || meta.name || e.station_name || e.station || null,
          lat: meta.lat,
          lon: meta.lon,
        };
      });
    }

    function aggregateStations(events) {
      const map = new Map();
      for (const e of events) {
        const key = e.station_id || e.station || 'unknown';
        const entry = map.get(key) || {
          station_id: key,
          name: e.station_name || String(key),
          IN: 0,
          OUT: 0,
          lat: e.lat,
          lon: e.lon,
        };
        entry[e.type] = (entry[e.type] || 0) + 1;
        entry.lat = entry.lat ?? e.lat;
        entry.lon = entry.lon ?? e.lon;
        map.set(key, entry);
      }
      return Array.from(map.values());
    }

    function groupDaily(events) {
      const daily = {};
      for (const e of events) {
        const day = e.ts.toISOString().slice(0, 10);
        const bucket = daily[day] || { IN: 0, OUT: 0 };
        bucket[e.type] = (bucket[e.type] || 0) + 1;
        daily[day] = bucket;
      }
      return Object.entries(daily)
        .sort(([a], [b]) => a.localeCompare(b))
        .map(([day, counts]) => ({ day, ...counts }));
    }

    function topStations(events) {
      const map = new Map();
      for (const e of events) {
        const key = e.station_id || e.station || 'unknown';
        const entry = map.get(key) || { name: e.station_name || String(key), IN: 0, OUT: 0 };
        entry[e.type] = (entry[e.type] || 0) + 1;
        map.set(key, entry);
      }
      return Array.from(map.values())
        .sort((a, b) => b.IN + b.OUT - (a.IN + a.OUT))
        .slice(0, 15);
    }

    function updateSummary(events) {
      const count = events.length;
      const vehicles = new Set(events.map((e) => e.v)).size;
      const dates = events.map((e) => e.ts.getTime());
      const min = dates.length ? new Date(Math.min(...dates)) : null;
      const max = dates.length ? new Date(Math.max(...dates)) : null;
      document.getElementById('eventsCount').textContent = count ? count.toLocaleString('fr-FR') : '–';
      document.getElementById('vehiclesCount').textContent = vehicles || '–';
      document.getElementById('dateRange').textContent = min ? `${min.toISOString().slice(0, 10)} → ${max.toISOString().slice(0, 10)}` : '–';
    }

    function renderDailyChart(daily) {
      if (!daily.length) { Plotly.purge('dailyChart'); return; }
      const traceIn = { x: daily.map((d) => d.day), y: daily.map((d) => d.IN || 0), type: 'bar', name: 'IN', marker: { color: '#0a84ff' } };
      const traceOut = { x: daily.map((d) => d.day), y: daily.map((d) => d.OUT || 0), type: 'bar', name: 'OUT', marker: { color: '#34c759' } };
      Plotly.newPlot('dailyChart', [traceIn, traceOut], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#0f172a' },
        barmode: 'group',
        margin: { t: 30, r: 10, l: 50, b: 60 },
      }, { responsive: true, displaylogo: false });
    }

    function renderStationChart(stations) {
      if (!stations.length) { Plotly.purge('stationChart'); return; }
      const names = stations.map((s) => s.name || '–');
      Plotly.newPlot('stationChart', [
        { x: names, y: stations.map((s) => s.IN || 0), type: 'bar', name: 'IN', marker: { color: '#0a84ff' } },
        { x: names, y: stations.map((s) => s.OUT || 0), type: 'bar', name: 'OUT', marker: { color: '#34c759' } },
      ], {
        paper_bgcolor: 'rgba(0,0,0,0)',
        plot_bgcolor: 'rgba(0,0,0,0)',
        font: { color: '#0f172a' },
        barmode: 'stack',
        margin: { t: 30, r: 10, l: 60, b: 120 },
      }, { responsive: true, displaylogo: false });
    }

    let mapInstance = null;
    let mapLayerGroup = null;
    let routeMap = null;
    let routeLayerGroup = null;
    let stationLookup = new Map();

    const uiState = {
      events: [],
      stations: [],
      trips: [],
      filteredTrips: [],
      selectedStation: 'all',
      hourStart: 0,
      hourEnd: 23,
      selectedVehicle: null,
    };

    function renderMap(stations) {
      const withCoords = stations.filter((s) => s.lat && s.lon);
      const status = document.getElementById('mapStatus');

      if (!mapInstance) {
        mapInstance = L.map('map').setView([45.1885, 5.7245], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '&copy; OpenStreetMap contributors',
          maxZoom: 19,
        }).addTo(mapInstance);
        mapLayerGroup = L.layerGroup().addTo(mapInstance);
      }

      mapLayerGroup.clearLayers();

      if (!withCoords.length) {
        mapInstance.setView([45.1885, 5.7245], 13);
        if (status) {
          status.textContent = 'Aucune station géolocalisée dans les données chargées.';
        }
        return;
      }

      const bounds = [];

      for (const station of withCoords) {
        const total = (station.IN || 0) + (station.OUT || 0);
        const popup = `<strong>${station.name || 'Station inconnue'}</strong><br/>IN: ${station.IN || 0}<br/>OUT: ${station.OUT || 0}<br/>Total: ${total}`;
        const marker = L.circleMarker([station.lat, station.lon], {
          radius: Math.max(6, Math.min(14, total / 10)),
          color: '#0a84ff',
          weight: 2,
          fillColor: '#34c759',
          fillOpacity: 0.7,
        }).bindPopup(popup);
        marker.addTo(mapLayerGroup);
        bounds.push([station.lat, station.lon]);
      }

      if (bounds.length) {
        mapInstance.fitBounds(bounds, { padding: [20, 20] });
        if (status) {
          status.textContent = `${withCoords.length} station(s) géolocalisée(s) affichée(s) sur Grenoble.`;
        }
      }
    }

    function buildTrips(events, toleranceHours = 12) {
      const byVehicle = new Map();
      const trips = [];
      const maxDelta = toleranceHours * 60 * 60 * 1000;
      for (const evt of events) {
        if (!evt?.ts) continue;
        if (evt.type === 'OUT') {
          byVehicle.set(evt.v, evt);
        } else if (evt.type === 'IN') {
          const prev = byVehicle.get(evt.v);
          if (prev && evt.ts - prev.ts <= maxDelta) {
            trips.push({
              vehicle: evt.v,
              startTs: prev.ts,
              endTs: evt.ts,
              startStationId: prev.station_id ?? prev.station ?? 'unknown',
              endStationId: evt.station_id ?? evt.station ?? 'unknown',
              startName: prev.station_name || prev.station || 'Station inconnue',
              endName: evt.station_name || evt.station || 'Station inconnue',
              startLat: prev.lat,
              startLon: prev.lon,
              endLat: evt.lat,
              endLon: evt.lon,
              durationMin: (evt.ts - prev.ts) / 60000,
            });
          }
          byVehicle.delete(evt.v);
        }
      }
      return trips;
    }

    function populateStationSelect(stations) {
      const select = document.getElementById('stationSelect');
      select.innerHTML = '';
      const allOption = document.createElement('option');
      allOption.value = 'all';
      allOption.textContent = 'Toutes les stations';
      select.appendChild(allOption);
      stations
        .filter((s) => s.station_id !== undefined)
        .sort((a, b) => (a.name || '').localeCompare(b.name || ''))
        .forEach((station) => {
          const opt = document.createElement('option');
          opt.value = String(station.station_id);
          opt.textContent = station.name || station.station_id;
          select.appendChild(opt);
        });
      select.value = uiState.selectedStation || 'all';
    }

    function formatHourRange(start, end) {
      return `${String(start).padStart(2, '0')}h-${String(end).padStart(2, '0')}h`;
    }

    function filterTrips() {
      const { selectedStation, hourStart, hourEnd, selectedVehicle } = uiState;
      const normalizedStart = Math.max(0, Math.min(23, Number(hourStart)));
      const normalizedEnd = Math.max(0, Math.min(23, Number(hourEnd)));
      const inRange = (date) => {
        const h = date.getHours();
        if (normalizedStart <= normalizedEnd) return h >= normalizedStart && h <= normalizedEnd;
        return h >= normalizedStart || h <= normalizedEnd;
      };
      const filtered = uiState.trips.filter((trip) => {
        const stationMatch =
          selectedStation === 'all' ||
          String(trip.startStationId) === String(selectedStation) ||
          String(trip.endStationId) === String(selectedStation);
        const hourMatch = inRange(trip.startTs) || inRange(trip.endTs);
        const vehicleMatch = !selectedVehicle || trip.vehicle === selectedVehicle;
        return stationMatch && hourMatch && vehicleMatch;
      });
      uiState.filteredTrips = filtered;
      renderTripSummary();
      renderVehicleList();
      renderRouteMap();
    }

    function renderTripSummary() {
      const summary = document.getElementById('tripSummary');
      if (!uiState.trips.length) {
        summary.textContent = 'Aucun trajet reconstitué pour les données chargées.';
        return;
      }
      const vehicles = new Set(uiState.filteredTrips.map((t) => t.vehicle)).size;
      summary.textContent = `${uiState.filteredTrips.length} trajets – ${vehicles} véhicule(s) – plage ${formatHourRange(uiState.hourStart, uiState.hourEnd)}.`;
    }

    function renderVehicleList() {
      const container = document.getElementById('vehiclesList');
      container.innerHTML = '';
      const vehicles = Array.from(new Set(uiState.trips.map((t) => t.vehicle))).sort();
      const filteredVehicles = new Set(uiState.filteredTrips.map((t) => t.vehicle));
      vehicles.forEach((vehicle) => {
        const count = uiState.filteredTrips.filter((t) => t.vehicle === vehicle).length;
        const button = document.createElement('div');
        button.className = `vehicle-item${uiState.selectedVehicle === vehicle ? ' active' : ''}`;
        button.textContent = count ? `${vehicle} (${count})` : `${vehicle} (hors filtre)`;
        button.style.opacity = filteredVehicles.has(vehicle) ? '1' : '0.5';
        button.addEventListener('click', () => {
          uiState.selectedVehicle = uiState.selectedVehicle === vehicle ? null : vehicle;
          filterTrips();
        });
        container.appendChild(button);
      });
      if (!vehicles.length) {
        container.innerHTML = '<span class="muted-text">Aucun véhicule détecté.</span>';
      }
    }

    function ensureRouteMap() {
      if (!routeMap) {
        routeMap = L.map('routeMap');
        L.tileLayer('https://{s}.basemaps.cartocdn.com/light_nolabels/{z}/{x}/{y}{r}.png', {
          attribution: '&copy; OpenStreetMap, © Carto',
          maxZoom: 18,
        }).addTo(routeMap);
        routeLayerGroup = L.layerGroup().addTo(routeMap);
      }
    }

    function renderRouteMap() {
      ensureRouteMap();
      routeLayerGroup.clearLayers();
      if (!uiState.filteredTrips.length) {
        routeMap.setView([45.1885, 5.7245], 12);
        return;
      }

      const bounds = [];
        const addStationMarker = (id, name, lat, lon) => {
          if (!lat || !lon) return;
          if (stationLookup.has(id)) return;
          const marker = L.circleMarker([lat, lon], {
            radius: 7,
            color: '#0a84ff',
            weight: String(uiState.selectedStation) === String(id) ? 3 : 1.5,
            fillColor: '#34c759',
            fillOpacity: 0.7,
          }).bindPopup(`<strong>${name || 'Station'}</strong><br/><span class="badge">Cliquer pour filtrer</span>`);
        marker.on('click', () => {
          uiState.selectedStation = String(id);
          document.getElementById('stationSelect').value = String(id);
          filterTrips();
        });
        marker.addTo(routeLayerGroup);
        bounds.push([lat, lon]);
        stationLookup.set(id, marker);
      };

      stationLookup = new Map();
      uiState.filteredTrips.forEach((trip) => {
        addStationMarker(trip.startStationId, trip.startName, trip.startLat, trip.startLon);
        addStationMarker(trip.endStationId, trip.endName, trip.endLat, trip.endLon);
        if (trip.startLat && trip.startLon && trip.endLat && trip.endLon) {
          const line = L.polyline(
            [
              [trip.startLat, trip.startLon],
              [trip.endLat, trip.endLon],
            ],
            {
              color: uiState.selectedVehicle && uiState.selectedVehicle === trip.vehicle ? '#ff9f0a' : '#0a84ff',
              weight: uiState.selectedVehicle && uiState.selectedVehicle === trip.vehicle ? 5 : 3.5,
              opacity: 0.8,
            }
          ).bindPopup(
            `<div><strong>Véhicule ${trip.vehicle}</strong><br/>${trip.startName} → ${trip.endName}<br/>Durée : ${trip.durationMin.toFixed(1)} min</div>`
          );
          line.addTo(routeLayerGroup);
          bounds.push([trip.startLat, trip.startLon], [trip.endLat, trip.endLon]);
        }
      });

      if (bounds.length) {
        routeMap.fitBounds(bounds, { padding: [20, 20] });
      }
    }

    async function parseCsv(text) {
      const parseCoordinate = (value) => {
        if (value === undefined || value === null || value === '') return null;
        if (typeof value === 'number') return value;
        const normalized = value.toString().replace(',', '.');
        const parsed = Number.parseFloat(normalized);
        return Number.isFinite(parsed) ? parsed : null;
      };

      const normalizeRow = (row) => {
        const cleaned = {};
        for (const [key, value] of Object.entries(row)) {
          const normalizedKey = key.replace(/^\ufeff/, '').trim();
          cleaned[normalizedKey] = value;
        }
        return cleaned;
      };

      return new Promise((resolve, reject) => {
        Papa.parse(text, {
          header: true,
          skipEmptyLines: true,
          complete: (results) => {
            const normalized = results.data.map((rawRow) => {
              const row = normalizeRow(rawRow);
              return {
                ...row,
                station_id: row.station_id ?? row.id ?? row.station ?? row['station id'],
                lat: parseCoordinate(row.lat),
                lon: parseCoordinate(row.lon),
              };
            });
            resolve(normalized);
          },
          error: reject,
        });
      });
    }

    async function handleFiles(ndjsonFiles, stationFile) {
      const ndjsonContents = await Promise.all(ndjsonFiles.map(readFileText));
      const rawEvents = ndjsonContents.flatMap(parseNdjson);
      const filtered = filterEvents(rawEvents);
      const stationContent = stationFile ? await readFileText(stationFile) : null;
      const stations = stationContent ? await parseCsv(stationContent) : [];
      const enriched = attachStations(filtered, stations);
      uiState.events = enriched;
      uiState.stations = stations;
      uiState.trips = buildTrips(enriched);
      updateSummary(enriched);
      renderDailyChart(groupDaily(enriched));
      const stationAggregates = aggregateStations(enriched);
      renderStationChart(topStations(enriched));
      renderMap(stationAggregates);
      populateStationSelect(stationAggregates);
      filterTrips();
    }

    async function fetchWithFallback(urls) {
      for (const url of urls) {
        const response = await fetch(url);
        if (response.ok) return response.text();
      }
      throw new Error(`Aucune des URLs suivantes n'a pu être chargée : ${urls.join(', ')}`);
    }

    async function loadDemo() {
      try {
        const ndjsonText = await fetchWithFallback([
          './voi_gbfs_grenoble_20251205_180959.ndjson',
          'https://raw.githubusercontent.com/tokojimo/VOI/main/voi_gbfs_grenoble_20251205_180959.ndjson',
        ]);

        const stationsText = await fetchWithFallback([
          './voi_stations_grenoble_20251213_175232.csv',
          'https://raw.githubusercontent.com/tokojimo/VOI/main/voi_stations_grenoble_20251213_175232.csv',
        ]);

        const rawEvents = parseNdjson(ndjsonText);
        const filtered = filterEvents(rawEvents);
        const stations = await parseCsv(stationsText);
        const enriched = attachStations(filtered, stations);
        uiState.events = enriched;
        uiState.stations = stations;
        uiState.trips = buildTrips(enriched);
        updateSummary(enriched);
        renderDailyChart(groupDaily(enriched));
        const stationAggregates = aggregateStations(enriched);
        renderStationChart(topStations(enriched));
        renderMap(stationAggregates);
        populateStationSelect(stationAggregates);
        filterTrips();
      } catch (err) {
        console.error(err);
        alert('Impossible de charger les fichiers de démonstration.');
      }
    }

    document.getElementById('demoBtn').addEventListener('click', loadDemo);
    document.getElementById('stationSelect').addEventListener('change', (event) => {
      uiState.selectedStation = event.target.value;
      filterTrips();
    });
    document.getElementById('startHour').addEventListener('change', (event) => {
      uiState.hourStart = Number(event.target.value);
      filterTrips();
    });
    document.getElementById('endHour').addEventListener('change', (event) => {
      uiState.hourEnd = Number(event.target.value);
      filterTrips();
    });
    document.getElementById('resetFilters').addEventListener('click', () => {
      uiState.selectedStation = 'all';
      uiState.selectedVehicle = null;
      uiState.hourStart = 0;
      uiState.hourEnd = 23;
      document.getElementById('stationSelect').value = 'all';
      document.getElementById('startHour').value = 0;
      document.getElementById('endHour').value = 23;
      filterTrips();
    });
    loadDemo();
  </script>
</body>
</html>
